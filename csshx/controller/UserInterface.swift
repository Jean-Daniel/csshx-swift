//
//  UserInterface.swift
//  csshx
//
//  Created by Jean-Daniel Dupas on 24/10/2023.
//

import Foundation
import RegexBuilder
import System

// MARK: - Input Modes
struct InputMode: Equatable {
  // Using autogenerated id to detect input mode change
  let id: UUID = UUID.init()
  let raw: Bool

  let prompt: (Controller) -> String
  let onEnable: (Controller) throws -> Void
  let parseInput: (Controller, inout [UInt8]) throws -> Void

  init(raw: Bool = true,
       prompt: @escaping (Controller) -> String,
       onEnable: @escaping (Controller) -> Void,
       parseInput: @escaping (Controller, inout [UInt8]) throws -> Void) {
    self.raw = raw
    self.prompt = prompt
    self.onEnable = onEnable
    self.parseInput = parseInput
  }

  static func beep() {
    fwrite(str: "\u{007}")
  }

  static func == (lhs: InputMode, rhs: InputMode) -> Bool {
    lhs.id == rhs.id
  }
}

// MARK: -
let csiCursorCode = Regex {
  "\u{001b}["
  Capture("A"..."D")
}

extension InputMode {
  static let starting: InputMode = InputMode { ctrl in
    "Starting hosts: \(ctrl.hosts.count { $0.connection != nil } )/\(ctrl.hosts.count)â€¦\r\n"
  } onEnable: { ctrl in
    // noop
  } parseInput: { ctrl, data in
    // Discarding all input until ready.
    data.removeAll()
  }
}

extension InputMode {
  static let input: InputMode = InputMode { ctrl in
    "Input to terminal: (Ctrl-\(ctrl.settings.actionKey.ascii) to enter control mode)\r\n"
  } onEnable: { ctrl in
    // noop
  } parseInput: { ctrl, data in
    // In input mode, data is always fully consummed.
    let action = ctrl.settings.actionKey
    // Convert CSI to SS3 cursor codes
    // \e[(A-D) -> \eO(A-D)
    //    if data.count >= 3 && data.starts(with: [ 27, 91 ]) && (65...68).contains(data[2]) {
    //      data[1] = 79
    //    }

    if let escape = data.firstIndex(of: action.value) {
      // Send data until escape sequence.
      if (escape > 0) {
        ctrl.send(bytes: data[0..<escape])
        // drop sent data + escape sequence
        data.removeSubrange(0...escape)
      } else {
        data.removeFirst()
      }
      // Switch mode
      try ctrl.setInputMode(.action)
    } else {
      // Forward all
      ctrl.send(bytes: data)
      data.removeAll()
    }
  }
}

// MARK: -
extension InputMode {
  static let action: InputMode = InputMode { ctrl in
    let enabled = ctrl.hosts.allSatisfy(\.enabled)
    let escape = "Ctrl-\(ctrl.settings.actionKey.ascii)"
    return "Actions (Esc to exit, \(escape) to send \(escape) to input)\r\n" +
    "[c]reate window, [r]etile, s[o]rt, [e]nable/disable input, e[n]able all, " +
    // ( (!ctrl.hosts.isEmpty) && (enabled) ? "[Space] Enable next " : "") +
    "[t]oggle enabled, [m]inimise, [h]ide, [s]end text, change [b]ounds, " +
    "chan[g]e [G]rid, e[x]it\r\n";
  } onEnable: { ctrl in

  } parseInput: { ctrl, data in
    let ch = data.removeFirst()
    switch (ch) {
      case ctrl.settings.actionKey.value:
        ctrl.send(bytes: [ctrl.settings.actionKey.value])
        try ctrl.setInputMode(.input)

        // create window
      case Character("c").asciiValue:
        try ctrl.setInputMode(.addHost)

        // retile
      case Character("r").asciiValue:
        ctrl.layout()
        try ctrl.setInputMode(.input)

        // sort
      case Character("o").asciiValue:
        try ctrl.setInputMode(.sort)

        // enable/disable input
      case Character("e").asciiValue:
        try ctrl.setInputMode(.enable)

        // enable all
      case Character("n").asciiValue:
        ctrl.hosts.forEach {
          $0.tab.window.zoomed = false
          $0.enabled = false
        }
        try ctrl.setInputMode(.input)

        // toggle enabled
      case Character("t").asciiValue:
        ctrl.hosts.forEach {
          $0.tab.window.zoomed = false
          $0.enabled = !$0.enabled
        }
        try ctrl.setInputMode(.input)

        // Minimize
      case Character("m").asciiValue:
        ctrl.hosts.forEach { $0.tab.miniaturize() }
        try ctrl.setInputMode(.input)

        // Hide
      case Character("h").asciiValue:
        ctrl.hosts.forEach { $0.tab.hide() }
        try ctrl.setInputMode(.input)

        // Send Text
      case Character("s").asciiValue:
        try ctrl.setInputMode(.sendString)

        // Change bounds
      case Character("b").asciiValue:
        try ctrl.setInputMode(.bounds)

        // add grid row
      case Character("g").asciiValue:
        let rows = min(ctrl.windowManager.rows + 1, ctrl.hosts.count)
        ctrl.windowManager.rows = rows
        ctrl.layout()

        // remove grid row
      case Character("G").asciiValue:
        let rows = max(ctrl.windowManager.rows - 1, 1)
        ctrl.windowManager.rows = rows
        ctrl.layout()
      case Character("x").asciiValue:
        ctrl.close()

      case 0x1b: // escape (\e)
        // TODO: if is escape sequence -> delete it and beep.
        // else switch to input mode
        try ctrl.setInputMode(.input)

      default:
        beep()
/*
 if ($buffer =~ s/^ //) {
     my @enabled = grep {
         (! $_->disabled) && $_
     } CsshX::Master::Socket::Slave->slaves;
     if (@enabled == 1) { $enabled[0]->select_next(); }
     return $obj->set_mode_and_parse('input', $buffer);
 }
 */
    }
  }
}

// MARK: -
extension InputMode {
  static let bounds: InputMode = InputMode { ctrl in
    "\r\n"
  } onEnable: { ctrl in

  } parseInput: { ctrl, data in

  }
  /*
   'bounds' => {
       prompt => sub { "Move and resize master with mouse to define bounds: (Enter to accept, ".
       "Esc to cancel)\r\n".
       "(Also Arrow keys of h,j,k,l can move window, hold Ctrl to resize)\r\n".
       "[r]eset to default, [f]ull screen, [p]rint current bounds" },
       onchange => sub {
           my ($obj) = @_;
           $obj->master->format_resize;
           $obj->master->size_as_bounds;
           $_->hide foreach (CsshX::Master::Socket::Slave->slaves);
       },
       parse_buffer => sub {
           my ($obj, $buffer) = @_;
           while (length $buffer) {
               #print join(' ', map { unpack("H2", $_) } split //, $buffer)."\r\n";
               if ($buffer =~ s/^(\014|\e\[5C)//) {
                   $obj->master->grow(1,0);
               } elsif ($buffer =~ s/^(\010|\e\[5D)//) {
                   $obj->master->grow(-1,0);
               } elsif ($buffer =~ s/^(\012|\e\[5A)//) {
                   $obj->master->grow(0,1);
               } elsif ($buffer =~ s/^(\013|\e\[5B)//) {
                   $obj->master->grow(0,-1);
               } elsif ($buffer =~ s/^(l|\e\[C)//) {
                   $obj->master->move(1,0)
               } elsif ($buffer =~ s/^(h|\e\[D)//) {
                   $obj->master->move(-1,0);
               } elsif ($buffer =~ s/^(k|\e\[A)//) {
                   $obj->master->move(0,-1);
               } elsif ($buffer =~ s/^(j|\e\[B)//) {
                   $obj->master->move(0,1);
               } elsif ($buffer =~ s/^\r//) {
                   $obj->master->bounds_as_size;
                   $obj->master->format_master;
                   $obj->master->arrange_windows;
                   return $obj->set_mode_and_parse('input', $buffer);
               } elsif ($buffer =~ s/^\e//) {
                   $obj->master->format_master;
                   $obj->master->arrange_windows;
                   return $obj->set_mode_and_parse('input', $buffer);
               } elsif ($buffer =~ s/^r//) {
                   $obj->master->reset_bounds;
                   $obj->master->size_as_bounds;
               } elsif ($buffer =~ s/^p//) {
                   $obj->master->redraw;
                   my $b = $obj->master->bounds;
                   print "\r\n\r\nscreen_bounds = {".join(", ",@$b)."}\r\n";
               } elsif ($buffer =~ s/^f//) {
                   $obj->master->max_physical_bounds;
                   $obj->master->size_as_bounds;
               } else {
                   substr($buffer, 0, 1, '');
                   print "\007";
               }
           }
           $obj->set_read_buffer('');
       },
   },
   */
}

// MARK: -
extension InputMode {
  static let sendString: InputMode = InputMode { ctrl in
    "Send string to all active windows: (Esc to exit)\r\n" +
    "[h]ostname, [c]onnection string, window [i]d\r\n"
  } onEnable: { ctrl in

  } parseInput: { ctrl, data in
    let ch = data.removeFirst()
    switch (ch) {
        // hostname
      case Character("h").asciiValue:
        ctrl.hosts.forEach { host in
          guard let hostname = host.host.hostname.data(using: .utf8) else {
            logger.warning("failed to encode hostname into UTF8 data")
            return
          }
          ctrl.send(bytes: hostname, to: host)
        }
        try ctrl.setInputMode(.input)

        // connection string
      case Character("c").asciiValue:
        ctrl.hosts.forEach { host in
          guard let hostname = host.host.connectionString.data(using: .utf8) else {
            logger.warning("failed to encode hostname into UTF8 data")
            return
          }
          ctrl.send(bytes: hostname, to: host)
        }
        try ctrl.setInputMode(.input)

        // Window ID
      case Character("i").asciiValue:
        ctrl.hosts.forEach { host in
          guard let wid = String(host.tab.windowId).data(using: .utf8) else {
            logger.warning("failed to encode window ID into UTF8 data")
            return
          }
          ctrl.send(bytes: wid, to: host)
        }
        try ctrl.setInputMode(.input)

      case 0x1b: // escape (\e)
        // TODO: if is escape sequence -> delete it and beep.
        // else switch to input mode
        try ctrl.setInputMode(.input)

      default:
        beep()
    }
  }
}

// MARK: -
extension InputMode {
  static let sort: InputMode = InputMode { ctrl in
    "Choose sort order: (Esc to exit)\r\n" +
    "[h]ostname, window [i]d"
  } onEnable: { ctrl in

  } parseInput: { ctrl, data in
    let ch = data.removeFirst()
    switch (ch) {
        // hostname
      case Character("h").asciiValue:
        ctrl.hosts.sort { h1, h2 in
          // TODO: sort by port and username of hostname is not enough
          h1.host.hostname < h2.host.hostname
        }
        ctrl.layout()
        try ctrl.setInputMode(.input)

        // Window ID (should match original order as window ID are increasing)
      case Character("i").asciiValue:
        ctrl.hosts.sort { h1, h2 in
          h1.tab.windowId < h2.tab.windowId
        }
        ctrl.layout()
        try ctrl.setInputMode(.input)

      case 0x1b: // escape (\e)
        // TODO: if is escape sequence -> delete it and beep.
        // else switch to input mode
        try ctrl.setInputMode(.input)

      default:
        beep()
    }
  }
}

// MARK: -
extension InputMode {
  static let enable: InputMode = InputMode { ctrl in
    "Select window with Arrow keys or h,j,k,l: (Esc to exit)\r\n" +
    "[e]nable input, [d]isable input, disable [o]thers, disable [O]thers and zoom, [t]oggle input\r\n"
  } onEnable: { ctrl in
    ctrl.hosts.forEach { $0.tab.window.zoomed = false }
  } parseInput: { ctrl, data in

  }
  /*
   'enable' => {
       prompt => sub {  },
       onchange => sub { CsshX::Window::Slave->selection_on; },
       parse_buffer => sub {
           my ($obj, $buffer) = @_;

           while (length $buffer) {
               #print join(' ', map { unpack("H2", $_) } split //, $buffer)."\r\n";
               if ($buffer =~ s/^(l|\e\[C)//) {
                   CsshX::Window::Slave->select_move(1,0);
               } elsif ($buffer =~ s/^(h|\e\[D)//) {
                   CsshX::Window::Slave->select_move(-1,0);
               } elsif ($buffer =~ s/^(k|\e\[A)//) {
                   CsshX::Window::Slave->select_move(0,-1);
               } elsif ($buffer =~ s/^(j|\e\[B)//) {
                   CsshX::Window::Slave->select_move(0,1);
               } elsif ($buffer =~ s/^[\e\r]//) {
                   CsshX::Window::Slave->selection_off;
                   return $obj->set_mode_and_parse('input', $buffer);
               } elsif ($buffer =~ s/^d//) {
                   if (my $window = CsshX::Window::Slave->selected_window()) {
                       $window->set_disabled(1);
                   }
               } elsif ($buffer =~ s/^e//) {
                   if (my $window = CsshX::Window::Slave->selected_window()) {
                       $window->set_disabled(0);
                   }
               } elsif ($buffer =~ s/^t//) {
                   if (my $window = CsshX::Window::Slave->selected_window()) {
                       $window->set_disabled(!$window->disabled);
                   }
               } elsif ($buffer =~ s/^o//) {
                   if (my $selected = CsshX::Window::Slave->selected_window()) {
                       foreach my $window (CsshX::Master::Socket::Slave->slaves) {
                           $window->set_disabled(1) unless $window == $selected;
                       }
                       $selected->set_disabled(0);
                       CsshX::Window::Slave->selection_off;
                       return $obj->set_mode_and_parse('input', $buffer);
                   }
               } elsif ($buffer =~ s/^O//) {
                   if (my $selected = CsshX::Window::Slave->selected_window()) {
                       foreach my $window (CsshX::Master::Socket::Slave->slaves) {
                           $window->set_disabled(1) unless $window == $selected;
                       }
                       $selected->set_disabled(0);
                       CsshX::Window::Slave->selection_off;
                       $selected->zoom();
                       return $obj->set_mode_and_parse('input', $buffer);
                   }
               } else {
                   substr($buffer, 0, 1, '');
                   print "\007";
               }
           }
           $obj->set_read_buffer('');
       },
   },
   */
}

// MARK: -
extension InputMode {
  static let addHost: InputMode = InputMode(raw: false) { ctrl in
    "Add Host: "
  } onEnable: { ctrl in

  } parseInput: { ctrl, data in
//    if ($buffer =~ s/^([^\n]*)\e//) {
//        return $obj->set_mode_and_parse('input', $buffer);
//    } elsif ($buffer =~ s/^(.*?)\r?\n//) {
//        my $hostname = $1;
//        if (length $hostname) {
//            my $slaveid = CsshX::Master::Socket::Slave->next_slaveid;
//            my $sock = $config->sock;
//            my $login = $config->login || '';
//            my @config = @{$config->config};
//            my $slave = $obj->master->register_slave($slaveid, $hostname, undef, undef);
//            $slave->open_window(
//                __FILE__, '--slave', '--sock', $sock,
//                '--slavehost', $hostname, '--slaveid', $slaveid,
//                '--ssh', $config->ssh,
//                '--ssh_args', $config->ssh_args, '--debug', $config->debug,
//                $login  ? ( '--login',    $login  ) :(),
//                (map { ('--config', $_) } @config),
//            ) or return;
//
//            $slave->set_settings_set($config->slave_settings_set)
//                if $config->slave_settings_set;
//
//            $obj->master->arrange_windows;
//        }
//        return $obj->set_mode_and_parse('input', $buffer);
//    }
//    $obj->set_read_buffer($buffer);
  }
}

