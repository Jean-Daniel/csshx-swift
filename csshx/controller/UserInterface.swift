//
//  UserInterface.swift
//  csshx
//
//  Created by Jean-Daniel Dupas on 24/10/2023.
//

import Foundation
import RegexBuilder
import System

// Special match operator that consume
private func ~= (pattern: String, value: inout [UInt8]) -> Bool {
  guard !value.isEmpty, !pattern.isEmpty else { return false }

  if pattern.utf8.count == 1 {
    // Fast path
    if value[0] == pattern.utf8.first {
      value.removeFirst()
      return true
    }
    return false
  }

  if value.prefix(pattern.utf8.count).elementsEqual(pattern.utf8) {
    value.removeFirst(pattern.utf8.count)
    return true
  }
  return false
}

private func ~= (pattern: UInt8, value: inout [UInt8]) -> Bool {
  guard !value.isEmpty else { return false }

  if pattern == value[0] {
    value.removeFirst()
    return true
  }
  return false
}

// MARK: - Input Modes
struct InputMode: Equatable {
  // Using autogenerated id to detect input mode change
  let id: UUID = UUID.init()
  let raw: Bool

  let prompt: (Controller) -> String
  let onEnable: (Controller) throws -> Void
  let parseInput: (Controller, inout [UInt8]) throws -> Void

  init(raw: Bool = true,
       prompt: @escaping (Controller) -> String,
       onEnable: @escaping (Controller) -> Void,
       parseInput: @escaping (Controller, inout [UInt8]) throws -> Void) {
    self.raw = raw
    self.prompt = prompt
    self.onEnable = onEnable
    self.parseInput = parseInput
  }

  static func beep() {
    fwrite(str: "\u{007}")
  }

  static func == (lhs: InputMode, rhs: InputMode) -> Bool {
    lhs.id == rhs.id
  }
}

// MARK: -
let csiCursorCode = Regex {
  "\u{001b}["
  Capture("A"..."D")
}

extension InputMode {
  static let starting: InputMode = InputMode { ctrl in
    "Starting hosts: \(ctrl.hosts.count { $0.connection != nil } )/\(ctrl.hosts.count)…\r\n"
  } onEnable: { ctrl in
    // noop
  } parseInput: { ctrl, data in
    // Discarding all input until ready.
    data.removeAll()
  }
}

extension InputMode {
  static let input: InputMode = InputMode { ctrl in
    "Input to terminal: (Ctrl-\(ctrl.settings.actionKey.ascii) to enter control mode)\r\n"
  } onEnable: { ctrl in
    // noop
  } parseInput: { ctrl, data in
    // In input mode, data is always fully consummed.
    let action = ctrl.settings.actionKey
    // Convert CSI to SS3 cursor codes
    // \e[(A-D) -> \eO(A-D)
    //    if data.count >= 3 && data.starts(with: [ 27, 91 ]) && (65...68).contains(data[2]) {
    //      data[1] = 79
    //    }

    if let escape = data.firstIndex(of: action.value) {
      // Send data until escape sequence.
      if (escape > 0) {
        ctrl.send(bytes: data[0..<escape])
        // drop sent data + escape sequence
        data.removeSubrange(0...escape)
      } else {
        data.removeFirst()
      }
      // Switch mode
      try ctrl.setInputMode(.action)
    } else {
      // Forward all
      ctrl.send(bytes: data)
      data.removeAll()
    }
  }
}

// MARK: -
extension InputMode {
  static let action: InputMode = InputMode { ctrl in
    let enabled = ctrl.hosts.allSatisfy(\.enabled)
    let escape = "Ctrl-\(ctrl.settings.actionKey.ascii)"
    return "Actions (Esc to exit, \(escape) to send \(escape) to input)\r\n" +
    "[c]reate window, [r]etile, s[o]rt, [e]nable/disable input, e[n]able all, " +
    // ( (!ctrl.hosts.isEmpty) && (enabled) ? "[Space] Enable next " : "") +
    "[t]oggle enabled, [m]inimise, [h]ide, [s]end text, change [b]ounds, " +
    "chan[g]e [G]rid, e[x]it\r\n";
  } onEnable: { ctrl in

  } parseInput: { ctrl, data in
    if ctrl.settings.actionKey.value ~= data {
      ctrl.send(bytes: [ctrl.settings.actionKey.value])
      try ctrl.setInputMode(.input)
    } 

    // create window
    else if "c" ~= data {
      try ctrl.setInputMode(.addHost)
    } 

    // retile
    else if "r" ~= data {
      ctrl.layout()
      try ctrl.setInputMode(.input)
    } 

    // sort
    else if "o" ~= data {
      try ctrl.setInputMode(.sort)
    } 

    // enable/disable input
    else if "e" ~= data {
      try ctrl.setInputMode(.enable)
    } 

    // enable all
    else if "n" ~= data {
      ctrl.hosts.forEach {
        $0.tab.window.zoomed = false
        $0.enabled = true
      }
      try ctrl.setInputMode(.input)
    }

    // toggle enabled
    else if "t" ~= data {
      ctrl.hosts.forEach {
        $0.tab.window.zoomed = false
        $0.enabled = !$0.enabled
      }
      try ctrl.setInputMode(.input)
    } 

    // Minimize
    else if "m" ~= data {
      ctrl.hosts.forEach { $0.tab.miniaturize() }
      try ctrl.setInputMode(.input)
    }

    // Hide
    else if "h" ~= data {
      ctrl.hosts.forEach { $0.tab.hide() }
      try ctrl.setInputMode(.input)
    }

    // Send Text
    else if "s" ~= data {
      try ctrl.setInputMode(.sendString)
    }

    // Change bounds
    else if "b" ~= data {
      try ctrl.setInputMode(.bounds)
    }

    // add grid row
    else if "g" ~= data {
      //        let rows = min(ctrl.windowManager.rows + 1, ctrl.hosts.count)
      //        ctrl.windowManager.rows = rows
      //        ctrl.layout()
    }

    // remove grid row
    else if "G" ~= data {
      //        let rows = max(ctrl.windowManager.rows - 1, 1)
      //        ctrl.windowManager.rows = rows
      //        ctrl.layout()
    }

    // exit
    else if "x" ~= data {
      ctrl.close()
    } else if 0x1b ~= data {
      // escape (\e)
      // TODO: if is escape sequence -> delete it and beep.
      // else switch to input mode
      try ctrl.setInputMode(.input)
    } else {
      data.removeFirst()
      beep()
    }
/*
 if ($buffer =~ s/^ //) {
     my @enabled = grep {
         (! $_->disabled) && $_
     } CsshX::Master::Socket::Slave->slaves;
     if (@enabled == 1) { $enabled[0]->select_next(); }
     return $obj->set_mode_and_parse('input', $buffer);
 }
 */
  }
}

// MARK: -
extension InputMode {
  static let bounds: InputMode = InputMode { ctrl in
    "Move and resize master with mouse to define bounds: (Enter to accept, Esc to cancel)\r\n" +
    "(Also Arrow keys of h,j,k,l can move window, hold Ctrl to resize)\r\n" +
    "[r]eset to default, [f]ull screen, [p]rint current bounds"
  } onEnable: { ctrl in
    // hide all host windows
    // switch master to resizing mode (color, …)
    // resize master to match "layout manager" bounds
  } parseInput: { ctrl, data in
    /*
     my ($obj, $buffer) = @_;
     while (length $buffer) {
         #print join(' ', map { unpack("H2", $_) } split //, $buffer)."\r\n";
         if ($buffer =~ s/^(\014|\e\[5C)//) {
             $obj->master->grow(1,0);
         } elsif ($buffer =~ s/^(\010|\e\[5D)//) {
             $obj->master->grow(-1,0);
         } elsif ($buffer =~ s/^(\012|\e\[5A)//) {
             $obj->master->grow(0,1);
         } elsif ($buffer =~ s/^(\013|\e\[5B)//) {
             $obj->master->grow(0,-1);
         } elsif ($buffer =~ s/^(l|\e\[C)//) {
             $obj->master->move(1,0)
         } elsif ($buffer =~ s/^(h|\e\[D)//) {
             $obj->master->move(-1,0);
         } elsif ($buffer =~ s/^(k|\e\[A)//) {
             $obj->master->move(0,-1);
         } elsif ($buffer =~ s/^(j|\e\[B)//) {
             $obj->master->move(0,1);
         } elsif ($buffer =~ s/^\r//) {
             $obj->master->bounds_as_size;
             $obj->master->format_master;
             $obj->master->arrange_windows;
             return $obj->set_mode_and_parse('input', $buffer);
         } elsif ($buffer =~ s/^\e//) {
             $obj->master->format_master;
             $obj->master->arrange_windows;
             return $obj->set_mode_and_parse('input', $buffer);
         } elsif ($buffer =~ s/^r//) {
             $obj->master->reset_bounds;
             $obj->master->size_as_bounds;
         } elsif ($buffer =~ s/^p//) {
             $obj->master->redraw;
             my $b = $obj->master->bounds;
             print "\r\n\r\nscreen_bounds = {".join(", ",@$b)."}\r\n";
         } elsif ($buffer =~ s/^f//) {
             $obj->master->max_physical_bounds;
             $obj->master->size_as_bounds;
         } else {
             substr($buffer, 0, 1, '');
             print "\007";
         }
     }
     */
  }
}

// MARK: -
extension InputMode {
  static let sendString: InputMode = InputMode { ctrl in
    "Send string to all active windows: (Esc to exit)\r\n" +
    "[h]ostname, [c]onnection string, window [i]d\r\n"
  } onEnable: { ctrl in

  } parseInput: { ctrl, data in
    // hostname
    if "h" ~= data {
      ctrl.hosts.forEach { host in
        guard let hostname = host.host.hostname.data(using: .utf8) else {
          logger.warning("failed to encode hostname into UTF8 data")
          return
        }
        ctrl.send(bytes: hostname, to: host)
      }
      try ctrl.setInputMode(.input)
    }

    // connection string
    else if "c" ~= data {
      ctrl.hosts.forEach { host in
        guard let hostname = host.host.connectionString.data(using: .utf8) else {
          logger.warning("failed to encode hostname into UTF8 data")
          return
        }
        ctrl.send(bytes: hostname, to: host)
      }
      try ctrl.setInputMode(.input)
    } 

    // Window ID
    else if "i" ~= data {
      ctrl.hosts.forEach { host in
        guard let wid = String(host.tab.windowId).data(using: .utf8) else {
          logger.warning("failed to encode window ID into UTF8 data")
          return
        }
        ctrl.send(bytes: wid, to: host)
      }
      try ctrl.setInputMode(.input)
    } 

    else if 0x1b ~= data {
      // escape (\e)
      // TODO: if is escape sequence -> delete it and beep.
      // else switch to input mode
      try ctrl.setInputMode(.input)
    } else {
      data.removeFirst()
      beep()
    }
  }
}

// MARK: -
extension InputMode {
  static let sort: InputMode = InputMode { ctrl in
    "Choose sort order: (Esc to exit)\r\n" +
    "[h]ostname, window [i]d"
  } onEnable: { ctrl in

  } parseInput: { ctrl, data in

    // hostname
    if "h" ~= data {
      ctrl.hosts.sort { h1, h2 in
        // TODO: sort by port and username of hostname is not enough
        h1.host.hostname < h2.host.hostname
      }
      ctrl.layout()
      try ctrl.setInputMode(.input)
    }

    // Window ID (should match original order as window ID are increasing)
    else if "i" ~= data {
      ctrl.hosts.sort { h1, h2 in
        h1.tab.windowId < h2.tab.windowId
      }
      ctrl.layout()
      try ctrl.setInputMode(.input)
    }

    else if 0x1b ~= data {
      // escape (\e)
      // TODO: if is escape sequence -> delete it and beep.
      // else switch to input mode
      try ctrl.setInputMode(.input)
    } else {
      data.removeFirst()
      beep()
    }
  }
}

// MARK: -
extension InputMode {

  // TODO: multi screen support -> add an keystroke to move to the next screen (maybe space).
  // TODO: Add the screen ID in the prompt ?
  static let enable: InputMode = InputMode { ctrl in
    "Select window with Arrow keys or h,j,k,l: (Esc to exit)\r\n" +
    "[e]nable input, [d]isable input, disable [o]thers, disable [O]thers and zoom, [t]oggle input\r\n"
  } onEnable: { ctrl in
    ctrl.hosts.forEach { $0.tab.window.zoomed = false }
    // select first host window
    ctrl.hosts.first?.selected = true
  } parseInput: { ctrl, data in
    // ↑
    if "i" ~= data || "\u{001b}[A" ~= data {
      if let selected = ctrl.hosts.first(where: \.selected),
         let next = ctrl.windowManager.getHostAbove(selected.id).flatMap({ hid in
           ctrl.hosts.first { $0.id == hid }
         }) {
        selected.selected = false
        next.selected = true
      }
    }
    // ↓
    else if "k" ~= data || "\u{001b}[B" ~= data {
      if let selected = ctrl.hosts.first(where: \.selected),
         let next = ctrl.windowManager.getHostBelow(selected.id).flatMap({ hid in
           ctrl.hosts.first { $0.id == hid }
         }) {
        selected.selected = false
        next.selected = true
      }
    }
    // →
    else if "l" ~= data || "\u{001b}[C" ~= data {
      if let selected = ctrl.hosts.first(where: \.selected),
         let next = ctrl.windowManager.getHostAfter(selected.id).flatMap({ hid in
           ctrl.hosts.first { $0.id == hid }
         }) {
        selected.selected = false
        next.selected = true
      }
    }
    // ←
    else if "j" ~= data || "\u{001b}[D" ~= data {
      if let selected = ctrl.hosts.first(where: \.selected),
         let next = ctrl.windowManager.getHostBefore(selected.id).flatMap({ hid in
           ctrl.hosts.first { $0.id == hid }
         }) {
        selected.selected = false
        next.selected = true
      }
    }

    else if "e" ~= data {
      if let selected = ctrl.hosts.first(where: \.selected) {
        selected.enabled = true
      }
    }

    else if "d" ~= data {
      if let selected = ctrl.hosts.first(where: \.selected) {
        selected.enabled = false
      }
    }

    else if "t" ~= data {
      if let selected = ctrl.hosts.first(where: \.selected) {
        selected.enabled = !selected.enabled
      }
    }

    else if 0x1b ~= data || 0x0d ~= data {
      // escape (\e)
      // TODO: if is escape sequence -> delete it and beep.
      // else switch to input mode
      ctrl.hosts.forEach { $0.selected = false }
      try ctrl.setInputMode(.input)
    } else {
      data.removeFirst()
      beep()
    }

    /*
         #print join(' ', map { unpack("H2", $_) } split //, $buffer)."\r\n";
         if ($buffer =~ s/^o//) {
             if (my $selected = CsshX::Window::Slave->selected_window()) {
                 foreach my $window (CsshX::Master::Socket::Slave->slaves) {
                     $window->set_disabled(1) unless $window == $selected;
                 }
                 $selected->set_disabled(0);
                 CsshX::Window::Slave->selection_off;
                 return $obj->set_mode_and_parse('input', $buffer);
             }
         } elsif ($buffer =~ s/^O//) {
             if (my $selected = CsshX::Window::Slave->selected_window()) {
                 foreach my $window (CsshX::Master::Socket::Slave->slaves) {
                     $window->set_disabled(1) unless $window == $selected;
                 }
                 $selected->set_disabled(0);
                 CsshX::Window::Slave->selection_off;
                 $selected->zoom();
                 return $obj->set_mode_and_parse('input', $buffer);
             }
         }
     */
  }
}

// MARK: -
extension InputMode {
  static let addHost: InputMode = InputMode(raw: false) { ctrl in
    "Add Host: "
  } onEnable: { ctrl in

  } parseInput: { ctrl, data in
    // If data contains an escape char -> discard all data
    // This is different from original csshx which only discard data up to the escape char.
    if data.contains(27) {
      data.removeAll()
      try ctrl.setInputMode(.input)
    }
    guard var hostname = String(bytes: data, encoding: .utf8) else {
      data.removeAll()
      beep()
      return
    }
    // Whatever append -> discard buffer content
    data.removeAll()

    let (user, host, p) = try hostname.trimmingCharacters(in: .whitespacesAndNewlines).parseUserHostPort()
    let target = Target(user: user, hostname: host, port: p.flatMap(UInt16.init), command: nil)
    try ctrl.add(host: target) { error in
      if let error {
        logger.warning("error while starting host \(target.connectionString): \(error)")
      } else {
        ctrl.layout()
      }
    }
    try ctrl.setInputMode(.input)
  }
}

